#include "StlWriter.h"

#include <sstream>

template<class T> static inline T maybe_swap(T in) {
  if(!PLATFORM_LITTLE_ENDIAN)
    return ByteSwap(in);
  else
    return in;
}

static FString cook_path(const FString& filename) {
  return FPaths::ProjectContentDir() + TEXT("/") + filename;
}

static void output_ascii_vertex(std::ostringstream& o, const FVector& in,
				const FTransform* transform) {
  if(transform != nullptr) {
    FVector out = TransformVector(*transform, in);
    o << "        vertex " << out.X << " " << out.Y << " " << out.Z << "\n";
  }
  else {
    o << "        vertex " << in.X << " " << in.Y << " " << in.Z << "\n";
  }
}

static void output_binary_vec(std::ostringstream& o, const FVector& in,
			      const FTransform* transform) {
  FVector out;
  if(transform != nullptr) {
    out = TransformVector(*transform, in);
  }
  else {
    out = in;
  }
  out.X = maybe_swap(out.X);
  out.Y = maybe_swap(out.Y);
  out.Z = maybe_swap(out.Z);
  o.write(reinterpret_cast<char*>(&out), 12);
}

void UStlWriter::OutputAsciiStlFile(const TArray<FString>& comments,
				    const TArray<FBakedMesh>& meshes,
				    const TArray<FTransform>& transforms,
				    const FString& filename,
				    bool& saving_succeeded,
				    FString& failure_reason) {
  failure_reason = "";
  saving_succeeded = false;
  std::ostringstream o;
  o << "solid GeneratedShell";
  for(auto& comment : comments) {
    auto str = std::string(TCHAR_TO_UTF8(*comment));
    auto p = str.cbegin();
    o << " || ";
    while(p != str.cend() && *p == ' ') ++p;
    while(p != str.cend()) {
      if(*p == '\r') ++p;
      else if(*p == '\n') { o << " | "; ++p; }
      else o << *p++;
    }
  }
  o << "\n\n";
  for(int m = 0; m < meshes.Num(); ++m) {
    auto& mesh = meshes[m];
    if(!mesh.vertices) {
      failure_reason = "A mesh was NULL";
      return;
    }
    if(!mesh.indices) {
      failure_reason = "A mesh had null indices";
      return;
    }
    if(!mesh.texcoords) {
      failure_reason = "A mesh had null texcoords";
      return;
    }
    auto& vertices = *mesh.vertices;
    auto& indices = *mesh.indices;
    auto& texcoords = *mesh.texcoords;
    auto transform = m < transforms.Num() ? &transforms[m] : nullptr;
    for(auto it = indices.cbegin(); it != indices.cend();) {
      auto a_index = *it++;
      auto b_index = *it++;
      auto c_index = *it++;
      auto& a = vertices[a_index];
      auto& b = vertices[b_index];
      auto& c = vertices[c_index];
      auto d = b-a;
      auto e = c-a;
      auto n = FVector::CrossProduct(d, e);
      if(transform != nullptr) {
	FVector transformed = TransformVector(*transform, FVector4(n.X, n.Y, n.Z, 0.0f));
	n.X = transformed.X;
	n.Y = transformed.Y;
	n.Z = transformed.Z;
      }
      o << "facet normal " << n.X << " " << n.Y << " " << n.Z << "\n";
      o << "    outer loop\n";
      output_ascii_vertex(o, a, transform);
      output_ascii_vertex(o, b, transform);
      output_ascii_vertex(o, c, transform);
      o << "    endloop\n";
      o << "endfacet\n";
    }
  }
  o << "\nendsolid GeneratedShell\n";
  auto all = o.str();
  IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
  FString path = cook_path(filename);
  if(!path.EndsWith(FString(".stl"))) path += ".stl";
  std::unique_ptr<IFileHandle> file(PlatformFile.OpenWrite(*path));
  if(!file || !file->Write(reinterpret_cast<const uint8_t*>(all.data()),
                           all.length())) {
    failure_reason = "Unable to write file";
    return;
  }
  saving_succeeded = true;
}

void UStlWriter::OutputBinaryStlFile(const TArray<FString>& comments,
				     const TArray<FBakedMesh>& meshes,
				     const TArray<FTransform>& transforms,
				     const FString& filename,
				     bool& saving_succeeded,
				     FString& failure_reason) {
  failure_reason = "";
  saving_succeeded = false;
  std::ostringstream o;
  o << "BINARY STL FILE - GENERATED BY SHELL SHAPE GENERATOR                            ";
  size_t num_triangles = 0;
  for(int m = 0; m < meshes.Num(); ++m) {
    auto& mesh = meshes[m];
    if(!mesh.indices) {
      failure_reason = "A mesh had null indices";
      return;
    }
    num_triangles += mesh.indices->size() / 3;
  }
  num_triangles = maybe_swap(num_triangles);
  o.write(reinterpret_cast<char*>(&num_triangles), 4);
  for(int m = 0; m < meshes.Num(); ++m) {
    auto& mesh = meshes[m];
    if(!mesh.vertices) {
      failure_reason = "A mesh was NULL";
      return;
    }
    if(!mesh.indices) {
      failure_reason = "A mesh had null indices";
      return;
    }
    if(!mesh.texcoords) {
      failure_reason = "A mesh had null texcoords";
      return;
    }
    auto& vertices = *mesh.vertices;
    auto& indices = *mesh.indices;
    auto& texcoords = *mesh.texcoords;
    auto transform = m < transforms.Num() ? &transforms[m] : nullptr;
    for(auto it = indices.cbegin(); it != indices.cend();) {
      auto a_index = *it++;
      auto b_index = *it++;
      auto c_index = *it++;
      auto& a = vertices[a_index];
      auto& b = vertices[b_index];
      auto& c = vertices[c_index];
      auto d = b-a;
      auto e = c-a;
      auto n = FVector::CrossProduct(d, e);
      if(transform != nullptr) {
	FVector transformed = TransformVector(*transform, FVector4(n.X, n.Y, n.Z, 0.0f));
	n.X = transformed.X;
	n.Y = transformed.Y;
	n.Z = transformed.Z;
      }
      output_binary_vec(o, n, nullptr);
      output_binary_vec(o, a, transform);
      output_binary_vec(o, b, transform);
      output_binary_vec(o, c, transform);
      o.write("\0", 2);
    }
  }
  auto all = o.str();
  IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
  FString path = cook_path(filename);
  if(!path.EndsWith(FString(".stl"))) path += ".stl";
  std::unique_ptr<IFileHandle> file(PlatformFile.OpenWrite(*path));
  if(!file || !file->Write(reinterpret_cast<const uint8_t*>(all.data()),
                           all.length())) {
    failure_reason = "Unable to write file";
    return;
  }
  saving_succeeded = true;
}
